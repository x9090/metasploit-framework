require 'spec_helper'
require 'msf/core'

describe Msf::Exploit::Remote::BrowserExploitServer do

  subject(:server) do
    mod = Msf::Exploit::Remote.allocate
    mod.extend described_class
    mod.send(:initialize, {})
    mod
  end

  let(:service_double) do
    service = double('service')
    service.stub(:server_name=)
    service.stub(:add_resource)
    service
  end

  let(:expected_user_agent) do
    'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)'
  end

  let(:profile_name) do
    'random'
  end

  let(:expected_os_name) do
    'linux'
  end

  let(:exploit_page) do
    server.instance_variable_get(:@exploit_receiver_page)
  end

  let(:expected_profile) do
    {
      :source   =>'script',
      :os_name  =>'Windows XP',
      :ua_name  =>'MSIE',
      :ua_ver   =>'8.0',
      :arch     =>'x86',
      :office   =>'null',
      :activex  => [ {clsid: '{D27CDB6E-AE6D-11cf-96B8-444553540000}', method: 'LoadMovie'} ],
      :proxy    => false,
      :language => 'en-us',
      :tried    => true
    }
  end

  before do
    Rex::ServiceManager.stub(:start => service_double)
  end

  before(:each) do
    server.start_service
  end

  it_should_behave_like 'Msf::Exploit::JSObfu'

  describe "#get_module_resource" do
    it "should give me a URI to access the exploit page" do
      module_resource = server.get_module_resource
      expect(module_resource).to include(exploit_page)
    end
  end

  describe '#has_bad_activex?' do
    context 'when there is a bad activex' do
      let(:js_ax_value) { "#{expected_profile[:activex][0][:clsid]}=>#{expected_profile[:activex][0][:method]}=>false" }
      it 'returns false' do
        expect(server.has_bad_activex?(js_ax_value)).to be_truthy
      end
    end

    context 'when there is no bad activex' do
      let(:js_ax_value) { "#{expected_profile[:activex][0][:clsid]}=>#{expected_profile[:activex][0][:method]}=>true" }
      it 'returns true' do
        expect(server.has_bad_activex?(js_ax_value)).to be_falsey
      end
    end
  end

  describe "#get_bad_requirements" do
    let(:rejected_requirements) do
      server.get_bad_requirements(fake_profile)
    end

    context 'when given the expected profile' do
      it "should not contain any bad requirements" do
        expect(server.get_bad_requirements(expected_profile)).to eq([])
      end
    end

    context 'when attempting to match :os_name' do
      let(:fake_profile) do
        { :os_name => expected_os_name }
      end

      before do
        server.instance_variable_set(:@requirements, {:os_name => /win/i})
      end

      it "identifies :os_name as a requirement not met" do
        expect(rejected_requirements).to eq([:os_name])
      end
    end

    context 'when attempting to match :ua_ver' do
      context 'against version 25.0' do
        let(:expected_ua_ver) { '25.0' }
        let(:fake_profile) do
          { :ua_ver => expected_ua_ver }
        end

        before do
          server.instance_variable_set(:@requirements, {:ua_ver => ua_ver})
        end

        context "with the regex /26\.0$/" do
          let(:ua_ver) { /26\.0$/ }
          it "should reject :ua_ver" do
            expect(rejected_requirements).to include(:ua_ver)
          end
        end

        context "with the regex /25\.0$/" do
          let(:ua_ver) { /25\.0$/ }
          it "should accept :ua_ver" do
            expect(rejected_requirements).not_to include(:ua_ver)
          end
        end

        context "with a Proc that checks if version is between 1-5" do
          let(:ua_ver) { lambda{ |ver| ver.to_i.between?(1, 5) } }
          it "should reject :ua_ver" do
            expect(rejected_requirements).to include(:ua_ver)
          end
        end

        context "with a Proc that checks if version is between 20-26" do
          let(:ua_ver) { lambda{ |ver| ver.to_i.between?(20, 26) } }
          it "should accept :ua_ver" do
            expect(rejected_requirements).not_to include(:ua_ver)
          end
        end
      end
    end
  end

  describe "#init_profile" do
    it "should initialize an empety profile for tag 'random'" do
      server.init_profile(profile_name)
      ivar_target_profile = server.instance_variable_get(:@target_profiles)
      expect(ivar_target_profile).to eq({profile_name=>{}})
    end
  end

  describe "#get_profile" do
    it "should return nil when a profile isn't found" do
      server.init_profile(profile_name)
      p = server.get_profile("non_existent_profile")
      expect(p).to be_nil
    end

    it "returns a profile if found" do
      server.init_profile(profile_name)
      p = server.get_profile(profile_name)
      expect(p).to eq({})
    end
  end

  describe "#update_profile" do
    it "updates my target profile's :os_name information" do
      server.init_profile(profile_name)
      profile = server.get_profile(profile_name)
      server.update_profile(profile, :os_name, expected_os_name)
      profile = server.get_profile(profile_name)
      expect(profile[:os_name]).to eq(expected_os_name)
    end
  end

  describe "#get_detection_html" do
    it "returns the detection code that the client will get" do
      html = server.get_detection_html(expected_user_agent)
      expect(html).not_to eq('')
    end
  end

  describe "#on_request_exploit" do
    it "raises a NoMethodError if called" do
      fake_cli = nil
      fake_request = nil
      fake_browser_info = nil
      expect {
        server.on_request_exploit(fake_cli, fake_request, fake_browser_info)
      }.to raise_error
    end
  end

  describe "#get_target" do
    it "returns a target" do
      #
      # Using Object for Msf::Module::Target
      #
      expected_object = Object
      server.instance_variable_set(:@target, expected_object)
      server.get_target.should eq(expected_object)
    end
  end

  describe "#try_set_target" do
    it "Sets a target based on requirements" do
      #
      # This testcase needs to be better somehow, but not sure how to actually create
      # a Msf::Module::Target. All we're able to test here is making sure the method
      # doesn't raise anything by exercising the code.
      #
      server.instance_variable_set(:@requirements, {:os_name => /win/i})
      server.instance_variable_set(:@target, Object)
      server.try_set_target(expected_profile)
      server.get_target.should eq(Object)
    end
  end

  describe "#extract_requirements" do
    it "finds all the recognizable keys" do
      requirements = {:os_name=>"Windows XP", :ua_name=>"MSIE", :ua_ver=>"8.0"}
      matches = server.extract_requirements(requirements)
      expect(matches).to eq(requirements)
    end

    it "makes sure the keys are always symbols" do
      requirements = {'os_name'=>"Windows XP", 'ua_name'=>"MSIE"}
      matches = server.extract_requirements(requirements)
      matches.each do |k,v|
        expect(k.class).to eq(Symbol)
      end
    end
  end

  describe '#on_request_uri' do
    let(:cli)     { double(:peerhost => '0.0.0.0') }
    let(:cookie)  { '' }
    let(:headers) { {'Cookie' => cookie, 'User-Agent' => ''} }
    let(:body)    { '' }
    let(:cookie_name) { Msf::Exploit::Remote::BrowserExploitServer::DEFAULT_COOKIE_NAME }
    let(:request) do
      double(:body => body, :headers => headers, :uri => server.get_resource )
    end

    before do
      server.stub(:send_redirect)
      server.stub(:send_response)
      server.stub(:send_not_found)
    end

    context 'when a new visitor requests the exploit' do
      before { JSObfu.disabled = true }
      after  { JSObfu.disabled = false }

      it 'calls send_response once' do
        server.should_receive(:send_response).once
        server.on_request_uri(cli, request)
      end

      it 'serves the os.js detection script' do
        server.should_receive(:send_response) do |cli, html, headers|
          expect(html).to include('os_detect')
        end
        server.on_request_uri(cli, request)
      end
    end

    context 'when a returning visitor requests the exploit' do
      let(:body) { '' }
      let(:tag) { 'joe' }
      let(:cookie) { "#{cookie_name}=#{tag}" }

      before { server.init_profile(tag) }

      it 'calls send_redirect once' do
        server.should_receive(:send_redirect).once
        server.on_request_uri(cli, request)
      end

      it 'redirects to the exploit URL' do
        server.should_receive(:send_redirect) do |cli, url|
          expect(url).to end_with("#{exploit_page}/")
        end
        server.on_request_uri(cli, request)
      end
    end

    context 'when a returning visitor from a previous msf run requests the exploit' do
      let(:body) { '' }
      let(:tag) { 'joe' }
      let(:cookie) { "#{cookie_name}=#{tag}" }

      before { JSObfu.disabled = true }
      after  { JSObfu.disabled = false }

      it 'calls send_response once' do
        server.should_receive(:send_response).once
        server.on_request_uri(cli, request)
      end

      it 'serves the os.js detection script' do
        server.should_receive(:send_response) do |cli, html, headers|
          expect(html).to include('os_detect')
        end
        server.on_request_uri(cli, request)
      end
    end


  describe '#get_payload' do
    let(:cli) {
      Rex::Socket::Tcp
    }

    before(:each) do
      allow(cli).to receive(:peerhost).and_return('0.0.0.0')
      allow(cli).to receive(:peerport).and_return(4444)
    end

    let(:encoded) { '@EXE@' }

    let(:x86_payload) {
      double(:encoded => encoded, :arch => ['x86'])
    }

    let(:x86_64_payload) {
      double(:encoded => encoded, :arch => ['x86_64'])
    }

    context 'when the payload supports the visitor\'s browser architecture' do
      it 'returns a payload' do
        allow(server).to receive(:regenerate_payload).and_return(x86_payload)
        expect(server.get_payload(cli, expected_profile)).to eq(encoded)
      end
    end

    context 'when the payload does not support the visitor\'s browser architecture'  do
      it 'raises a BESException' do
        allow(server).to receive(:regenerate_payload).and_return(x86_64_payload)
        expect{server.get_payload(cli, expected_profile)}.to raise_error(Msf::Exploit::Remote::BrowserExploitServer::BESException)
      end
    end
  end

  end

end
